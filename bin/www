#!/usr/bin/env node

/**
 * Module dependencies.
 */

const debug = require('debug')('final-project:server');
const http = require('http');
const app = require('../app');
const eventBus = require('../pubsub');
const { socketToUser, userToSocket, roomStorage } = require('../rooms');
/**
 * Get port from environment and store in Express.
 */

const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

const server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    const port = parseInt(val, 10);

    if (isNaN(port)) {
    // named pipe
        return val;
    }

    if (port >= 0) {
    // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    const bind = typeof port === 'string'
        ? `Pipe ${port}`
        : `Port ${port}`;

    // handle specific listen errors with friendly messages
    switch (error.code) {
    case 'EACCES':
        console.error(`${bind} requires elevated privileges`);
        process.exit(1);
        break;
    case 'EADDRINUSE':
        console.error(`${bind} is already in use`);
        process.exit(1);
        break;
    default:
        throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    const address = server.address();
    const bind = typeof address === 'string'
        ? `pipe ${address}`
        : `port ${address.port}`;
    debug(`Listening on ${bind}`);
}

/**
 * Web socket implementation
 */
const io = require('socket.io')(server);

function getCreatorSocket(roomName) {
    const room = roomStorage[roomName];
    if (!room) {
        console.error('No room found!');
        return;
    }
    return userToSocket.get(room.creator);
}

io.on('connection', (socket) => {
    console.log('client connected');
    socket.on('disconnect', () => {
        console.log('client disconnected');
    });

    socket.on('settings.bindID', (user) => {
        console.log(user);
        socketToUser.put(socket.id, user.id);
        userToSocket.put(user.id, socket.id);
    });

    socket.on('settings.joinRoom', (data) => {
        console.log(data.roomName);
        socket.join(data.roomName);
    });

    socket.on('settings.notifyCreator', (data) => {
        const { roomName, user } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('settings.userJoined', user);
    });

    socket.on('creator.helpNeeded', (data) => {
        const { roomName, id } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.helpNeeded', id);
    });

    socket.on('creator.broadcastPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.updatePens', { id, pen });
    });

    socket.on('creator.switchPen', (data) => {
        const { roomName, id, newPen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.switchPen', { id, newPen });
    });

    socket.on('creator.deletedPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.deletedPen', { id, pen });
    });

    socket.on('pen.change', (data) => {
        console.log('update the pen');
        console.log(data);
        const userID = socketToUser.get(socket.id);
        const room = roomStorage[data.roomName];
        if (room.creator === userID && data.pen.title === 'Public') {
            room.publicPen = data.pen;
            // let socketID = userToSocket.get(userID);
            socket.to(room.name).emit('pen.update', data.pen);
            return;
        }

        if (room.creator === userID && data.pen.link) {
            const creatorPens = room.users[room.creator];
            for (let i = 0; i < creatorPens.length; i++) {
                if (creatorPens[i].id === data.pen.id) {
                    creatorPens[i] = data.pen;
                    break;
                }
            }

            const linkedUserPens = room.users[data.pen.link.userID];
            let found = -1;
            for (let i = 0; i < linkedUserPens.length; i++) {
                if (linkedUserPens[i].id === data.pen.link.penID) {
                    linkedUserPens[i].html = data.pen.html;
                    linkedUserPens[i].css = data.pen.css;
                    linkedUserPens[i].js = data.pen.js;
                    linkedUserPens[i].title = data.pen.title;
                    found = i;
                    break;
                }
            }

            if (found !== -1) {
                const destination = userToSocket.get(data.pen.link.userID);
                socket.to(destination).emit('pen.update', linkedUserPens[found]);
            }
            return;
        }

        const pens = room.users[userID];
        const creatorSocket = userToSocket.get(room.creator);
        console.log(pens);
        for (let i = 0; i < pens.length; i++) {
            const pen = pens[i];
            if (pen.id === data.pen.id) {
                pens[i] = data.pen;
                const creatorPens = room.users[room.creator];
                for (let j = 0; j < creatorPens.length; j++) {
                    if (creatorPens[j].link && creatorPens[j].link.penID === data.pen.id) {
                        creatorPens[j].html = data.pen.html;
                        creatorPens[j].css = data.pen.css;
                        creatorPens[j].js = data.pen.js;
                        creatorPens[j].title = data.pen.title;
                        break;
                    }
                }
                if (pen.title !== 'Public') {
                    socket.to(creatorSocket).emit('creator.updatePens', { id: userID, pen: pens[i] });
                }
            }
        }
    });

    socket.on('pen.preview', (data) => {
        let destination = data.roomName || userToSocket.get(data.userID) || userToSocket.get(data.pen.user);
        socket.to(destination).emit('pen.updatePreview', data.pen);
    });
});

eventBus.on('event', (event) => {
    io.emit('event', event);
});
