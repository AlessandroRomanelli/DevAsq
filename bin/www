#!/usr/bin/env node

/**
 * Module dependencies.
 */

const debug = require('debug')('final-project:server');
const http = require('http');
const app = require('../app');
const eventBus = require('../pubsub');
const { socketToUser, userToSocket, roomStorage } = require('../rooms');
/**
 * Get port from environment and store in Express.
 */

const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

const server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    const port = parseInt(val, 10);

    if (isNaN(port)) {
    // named pipe
        return val;
    }

    if (port >= 0) {
    // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    const bind = typeof port === 'string'
        ? `Pipe ${port}`
        : `Port ${port}`;

    // handle specific listen errors with friendly messages
    switch (error.code) {
    case 'EACCES':
        console.error(`${bind} requires elevated privileges`);
        process.exit(1);
        break;
    case 'EADDRINUSE':
        console.error(`${bind} is already in use`);
        process.exit(1);
        break;
    default:
        throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    const address = server.address();
    const bind = typeof address === 'string'
        ? `pipe ${address}`
        : `port ${address.port}`;
    debug(`Listening on ${bind}`);
}

/**
 * Web socket implementation
 */
const io = require('socket.io')(server);

function getCreatorSocket(roomName) {
    const room = roomStorage[roomName];
    if (!room) {
        console.error('No room found!');
        return;
    }
    return userToSocket.get(room.creator);
}

io.on('connection', (socket) => {
    console.log('client connected');
    socket.on('disconnect', () => {
        console.log('client disconnected');
    });

    socket.on('disconnecting', (reason) => {
        console.log('Deleting user from the server storage and notify all users');
        let userID = socketToUser.get(socket.id);
        if (Object.keys(socket.rooms).length > 1) {
            let roomName = Object.keys(socket.rooms)[1];
            console.log(socket.rooms);
            console.log(roomName);
            let room = roomStorage[roomName];
            console.log(room);
            if (room) {
                if (Object.keys(room.users).length === 0 || userID === room.creator) {
                    if (userID === room.creator) {
                        socket.to(roomName).emit('room.delete', roomName);
                    }
                    delete roomStorage[roomName];
                } else {
                    delete room.users[userID];
                    socket.to(userToSocket.get(room.creator)).emit('creator.userExit');
                }
            }
        }
    });

    socket.on('settings.bindID', (user) => {
        console.log(user);
        socketToUser.put(socket.id, user.id);
        userToSocket.put(user.id, socket.id);
    });

    socket.on('settings.joinRoom', (data) => {
        console.log(data.roomName);
        socket.join(data.roomName);
    });

    socket.on('settings.notifyCreator', (data) => {
        const { roomName, user } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('settings.userJoined', user);
    });

    socket.on('creator.helpNeeded', (data) => {
        const { roomName, id } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.helpNeeded', id);
    });

    socket.on('creator.broadcastPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.updatePens', { id, pen });
    });

    socket.on('creator.switchPen', (data) => {
        const { roomName, id, newPen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.switchPen', { id, newPen });
    });

    socket.on('creator.deletedPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.deletedPen', { id, pen });
    });

    socket.on('pen.change', (data) => {
        console.log('update the pen');
        console.log(data);
        const userID = socketToUser.get(socket.id);
        const room = roomStorage[data.roomName];
        if (room.creator === userID && data.pen.title === 'Public') {
            room.publicPen = data.pen;
            // let socketID = userToSocket.get(userID);
            socket.to(room.name).emit('pen.update', data.pen);
            return;
        }
        const pens = room.users[userID];
        const creatorSocket = userToSocket.get(room.creator);
        console.log(pens);
        for (let i = 0; i < pens.length; i++) {
            const pen = pens[i];
            if (pen.id === data.pen.id) {
                pens[i] = data.pen;
                if (pen.title !== 'Public') {
                    socket.to(creatorSocket).emit('creator.updatePens', { id: userID, pen: pens[i] });
                }
            }
        }
    });

    socket.on('pen.preview', (data) => {
        let destination = data.roomName || data.userID || userToSocket.get(data.pen.user);
        socket.to(destination).emit('pen.updatePreview', data.pen);
    });
});

eventBus.on('event', (event) => {
    io.emit('event', event);
});
