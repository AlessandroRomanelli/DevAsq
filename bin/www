#!/usr/bin/env node

/**
 * Module dependencies.
 */

const debug = require('debug')('final-project:server');
const http = require('http');
const app = require('../app');
const eventBus = require('../pubsub');
const { connectionMap, roomStorage } = require('../rooms');
/**
 * Get port from environment and store in Express.
 */

const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

const server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    const port = parseInt(val, 10);

    if (isNaN(port)) {
    // named pipe
        return val;
    }

    if (port >= 0) {
    // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    const bind = typeof port === 'string'
        ? `Pipe ${port}`
        : `Port ${port}`;

    // handle specific listen errors with friendly messages
    switch (error.code) {
    case 'EACCES':
        console.error(`${bind} requires elevated privileges`);
        process.exit(1);
        break;
    case 'EADDRINUSE':
        console.error(`${bind} is already in use`);
        process.exit(1);
        break;
    default:
        throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    const address = server.address();
    const bind = typeof address === 'string'
        ? `pipe ${address}`
        : `port ${address.port}`;
    debug(`Listening on ${bind}`);
}

/**
 * Web socket implementation
 */
const io = require('socket.io')(server);

function getCreatorSocket(roomName) {
    const room = roomStorage[roomName];
    if (!room) {
        console.error('No room found!');
        return null;
    }
    return connectionMap.getSocket(room.creator);
}

io.on('connection', (socket) => {
    console.log('client connected');
    socket.on('disconnect', () => {
        console.log('client disconnected');
    });

    socket.on('disconnecting', (reason) => {
        console.log('Deleting user from the server storage and notify all users');
        let userID = connectionMap.getUser(socket.id);

        if (Object.keys(socket.rooms).length > 1) {
            let roomName = Object.keys(socket.rooms)[1];
            let room = roomStorage[roomName];
            if (room) {
                if (userID === room.creator) {
                    socket.to(roomName).emit('room.delete', roomName);
                    delete roomStorage[roomName];
                } else {
                    delete room.users[userID];
                    socket.to(connectionMap.getSocket(room.creator)).emit('settings.userLeft', userID);
                }
            }
        }
    });

    socket.on('settings.bindID', (user) => {
        console.log(user);
        connectionMap.registerUser(user.id, socket.id);
    });

    socket.on('homePage.joinRoom', () => {
        socket.join('homePage');
    });

    socket.on('homePage.leaveRoom', () => {
        socket.leave('homePage');
    });

    socket.on('settings.joinRoom', (data) => {
        console.log(data);
        socket.join(data.roomName);
        socket.to('homePage').emit('homepage.updateRoomCounter', {
            population: data.population,
            roomName: data.roomName,
            passworded: data.passworded
        });
    });

    socket.on('settings.leaveRoom', (data) => {
        console.log(data);
        socket.leave(data.roomName);
    });

    socket.on('settings.notifyCreator', (data) => {
        const { roomName, user } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('settings.userJoined', user);
    });

    socket.on('creator.helpNeeded', (data) => {
        const { roomName, id } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.helpNeeded', id);
    });

    socket.on('creator.broadcastPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.updatePens', { id, pen });
    });

    socket.on('creator.switchPen', (data) => {
        const { roomName, id, newPen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.switchPen', { id, newPen });
    });

    socket.on('creator.deletedPen', (data) => {
        const { roomName, id, pen } = data;
        const creatorSocket = getCreatorSocket(roomName);
        if (!creatorSocket) return;
        socket.to(creatorSocket).emit('creator.deletedPen', { id, pen });
    });

    socket.on('pen.resolveHelp', (data) => {
        const { id } = data;
        const userSocket = connectionMap.getSocket(id);
        if (!userSocket) return;
        socket.to(userSocket).emit('pen.resolveHelp');
    });

    socket.on('pen.change', (data) => {
        console.log('update the pen');
        console.log(data);
        const userID = connectionMap.getUser(socket.id);
        const room = roomStorage[data.roomName];
        if (room && room.creator === userID && data.pen.title === 'Public') {
            room.publicPen = data.pen;
            // let socketID = userToSocket.get(userID);
            socket.to(room.name).emit('pen.update', data.pen);
            return;
        }

        if (room && room.creator === userID && data.pen.link) {
            const creatorPens = room.users[room.creator];
            for (let i = 0; i < creatorPens.length; i++) {
                if (creatorPens[i].id === data.pen.id) {
                    creatorPens[i] = data.pen;
                    break;
                }
            }

            const linkedUserPens = room.users[data.pen.link.userID];
            let found = -1;
            for (let i = 0; i < linkedUserPens.length; i++) {
                if (linkedUserPens[i].id === data.pen.link.penID) {
                    linkedUserPens[i].html = data.pen.html;
                    linkedUserPens[i].css = data.pen.css;
                    linkedUserPens[i].js = data.pen.js;
                    found = i;
                    break;
                }
            }

            if (found !== -1) {
                const destination = connectionMap.getSocket(data.pen.link.userID);
                socket.to(destination).emit('pen.update', linkedUserPens[found]);
            }
            return;
        }

        const pens = room.users[userID];
        const creatorSocket = connectionMap.getSocket(room.creator);
        console.log(pens);
        for (let i = 0; i < pens.length; i++) {
            const pen = pens[i];
            if (pen.id === data.pen.id) {
                pens[i] = data.pen;
                const creatorPens = room.users[room.creator];
                for (let j = 0; j < creatorPens.length; j++) {
                    if (creatorPens[j].link && creatorPens[j].link.penID === data.pen.id) {
                        creatorPens[j].html = data.pen.html;
                        creatorPens[j].css = data.pen.css;
                        creatorPens[j].js = data.pen.js;
                        creatorPens[j].title = data.pen.title;
                        break;
                    }
                }
                if (pen.title !== 'Public') {
                    socket.to(creatorSocket).emit('creator.updatePens', { id: userID, pen: pens[i] });
                }
            }
        }
    });

    socket.on('pen.preview', (data) => {
        console.log(data.pen);
        let destination;
        try {
            destination = data.roomName || connectionMap.getSocket(data.userID) || connectionMap.getSocket(data.pen.link.userID);
        } catch (e) {
            destination = undefined;
        }
        socket.to(destination).emit('pen.updatePreview', data.pen);
    });

    socket.on('pen.sharedCreated', (data) => {
        const { userID, penID } = data;
        const destination = connectionMap.getSocket(userID);
        socket.to(destination).emit('pen.sharedCreated', penID);
    });

    socket.on('pen.sharedDeleted', (data) => {
        const { userID, penID } = data;
        const destination = connectionMap.getSocket(userID);
        socket.to(destination).emit('pen.sharedDeleted', penID);
    });
});

eventBus.on('event', (event) => {
    io.emit('event', event);
});
